<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Recon HUD — Map + MJPEG Frustum</title>
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>

  <script type="importmap">
  { "imports": { "three": "https://unpkg.com/three@0.180.0/build/three.module.js" } }
  </script>

  <style>
    @font-face {
      font-family: 'NerdFont';
      src: url('https://cdn.jsdelivr.net/gh/ryanoasis/nerd-fonts@3.2.1/patched-fonts/JetBrainsMono/Ligatures/Regular/JetBrainsMonoNerdFont-Regular.ttf') format('truetype');
      font-weight: 400;
      font-style: normal;
      font-display: swap;
    }

    .nf {
      font-family: 'NerdFont', 'Symbols Nerd Font', 'Segoe UI Symbol', sans-serif;
      font-size: 0.85rem;
      line-height: 1;
    }

    .metric-row {
      display: grid;
      grid-auto-flow: column;
      grid-auto-columns: minmax(0, auto);
      column-gap: 0.6rem;
      row-gap: 0.25rem;
      align-items: center;
    }

    .metric-chip {
      display: inline-flex;
      align-items: center;
      gap: 0.2rem;
      white-space: nowrap;
      font-variant-numeric: tabular-nums;
    }

    [x-cloak] {
      display: none !important;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: #0b0f14;
      overflow: hidden;
    }

    #scene {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
    }

    #tileCanvas {
      display: none;
    }

    .attribution {
      position: absolute;
      bottom: 8px;
      left: 10px;
      font-size: 11px;
      color: #aab3c2;
      opacity: 0.85;
      z-index: 40;
    }
  </style>
</head>

<body x-data="hud()" class="overflow-hidden">
  <div class="fixed inset-0 z-[120] flex items-center justify-center bg-slate-950/90 backdrop-blur-sm"
    x-show="loading.active" x-transition.opacity>
    <div class="w-full max-w-sm px-8 text-center space-y-4">
      <div class="space-y-1">
        <div class="text-sm font-semibold text-slate-100" x-text="loading.label"></div>
        <div class="text-xs text-slate-400" x-text="`${loading.progress.toFixed(0)}%`"></div>
      </div>
      <div class="w-full h-2 rounded-full bg-slate-800/70 overflow-hidden">
        <div class="h-full bg-emerald-400 transition-all duration-300" :style="`width: ${loading.progress}%;`"></div>
      </div>
    </div>
  </div>
  <!-- HUD (pinned on top) -->
  <div class="pointer-events-none absolute top-0 left-0 w-full p-3 flex items-start gap-3 z-50">
    <!-- Single Recon Status card WITH Detections inside -->
    <div
      class="pointer-events-auto bg-slate-900/80 text-slate-100 rounded-xl p-3 shadow-lg border border-slate-700 min-w-[280px]">
      <div class="flex items-center justify-between mb-2">
        <div class="text-xs uppercase tracking-wider text-slate-400">HUD Panel</div>
        <button type="button" @click="togglePanel()"
          class="px-2 py-0.5 rounded border border-slate-700 bg-slate-800 text-xs font-semibold tracking-wide hover:bg-slate-700 transition"
          :class="panelCollapsed ? 'text-emerald-300 border-emerald-500/40' : 'text-slate-200'">
          <span x-show="!panelCollapsed" x-cloak>−</span>
          <span x-show="panelCollapsed" x-cloak>+</span>
        </button>
      </div>

      <div x-show="!panelCollapsed" x-transition x-cloak class="flex flex-col gap-3">
        <div class="border border-slate-700/60 rounded-lg bg-slate-900/60">
          <button type="button" @click="toggleSection('preview')"
            class="w-full flex items-center justify-between text-xs uppercase tracking-wider text-slate-300 px-2 py-1.5">
            <span>LivePreview</span>
            <span x-text="sections.preview ? '−' : '+'"></span>
          </button>
          <div x-show="sections.preview" x-transition x-cloak class="border-t border-slate-700/60 px-3 py-2 space-y-2">
            <div class="grid grid-cols-4 gap-1">
              <button @click="setPreviewMode('original')"
                class="px-2 py-0.5 rounded border text-[11px] font-semibold uppercase tracking-wide transition"
                :class="previewMode === 'original' ? 'bg-emerald-600 text-slate-100 border-emerald-400' : 'bg-slate-800 text-slate-300 border-slate-700 hover:bg-slate-700'">Orig</button>
              <button @click="setPreviewMode('delta')"
                class="px-2 py-0.5 rounded border text-[11px] font-semibold uppercase tracking-wide transition"
                :class="previewMode === 'delta' ? 'bg-emerald-600 text-slate-100 border-emerald-400' : 'bg-slate-800 text-slate-300 border-slate-700 hover:bg-slate-700'">ΔColor</button>
              <button @click="setPreviewMode('abs')"
                class="px-2 py-0.5 rounded border text-[11px] font-semibold uppercase tracking-wide transition"
                :class="previewMode === 'abs' ? 'bg-emerald-600 text-slate-100 border-emerald-400' : 'bg-slate-800 text-slate-300 border-slate-700 hover:bg-slate-700'">AbsDiff</button>
              <button @click="setPreviewMode('overlay')"
                class="px-2 py-0.5 rounded border text-[11px] font-semibold uppercase tracking-wide transition"
                :class="previewMode === 'overlay' ? 'bg-emerald-600 text-slate-100 border-emerald-400' : 'bg-slate-800 text-slate-300 border-slate-700 hover:bg-slate-700'">Overlay</button>
            </div>
            <canvas x-ref="previewCanvas" class="w-full max-w-xs rounded border border-slate-700 bg-black"
              style="aspect-ratio: 4 / 3; image-rendering: pixelated;"></canvas>
          </div>
        </div>

        <div class="border border-slate-700/60 rounded-lg bg-slate-900/60">
          <button type="button" @click="toggleSection('status')"
            class="w-full flex items-center justify-between text-xs uppercase tracking-wider text-slate-300 px-2 py-1.5">
            <span>Recon Status</span>
            <span x-text="sections.status ? '−' : '+'"></span>
          </button>
          <div x-show="sections.status" x-transition x-cloak
            class="border-t border-slate-700/60 px-3 py-2 text-sm space-y-0.5">
            <div>GPS: <span :class="geo.ok ? 'text-emerald-400' : 'text-amber-400'"
                x-text="geo.ok ? 'Locked' : 'Fallback'"></span></div>
            <div>Map: <span :class="map.ready ? 'text-emerald-400' : 'text-amber-400'"
                x-text="map.ready ? 'Ready' : 'Loading'"></span></div>
            <div>Stream: <span :class="stream.ok ? 'text-emerald-400' : 'text-rose-400'"
                x-text="stream.ok ? ('Receiving @ ' + stream.fps.toFixed(1) + ' fps') : 'Offline'"></span></div>
          </div>
        </div>

        <div class="border border-slate-700/60 rounded-lg bg-slate-900/60">
          <button type="button" @click="toggleSection('detections')"
            class="w-full flex items-center justify-between text-xs uppercase tracking-wider text-slate-300 px-2 py-1.5">
            <span>Detections</span>
            <span x-text="sections.detections ? '−' : '+'"></span>
          </button>
          <div x-show="sections.detections" x-transition x-cloak
            class="border-t border-slate-700/60 px-3 py-2 text-sm space-y-1">
            <div class="text-slate-300">
              Count: <span class="text-slate-100 font-semibold" x-text="uiDetections.length"></span>
            </div>
            <div class="max-h-48 overflow-y-auto pr-1 border border-slate-700/40 rounded-lg">
              <template x-if="uiDetections.length === 0">
                <div class="px-2 py-3 text-xs text-slate-500">No detections yet.</div>
              </template>
              <template x-for="d in uiDetections" :key="d.key">
                <div
                  class="px-2 py-1 grid grid-cols-[auto,1fr] gap-x-2 gap-y-0.5 items-center border-b border-slate-700/40 last:border-0">
                  <div class="w-3 h-3 rounded-full ring-1 ring-slate-700/60" :style="`background:${d.hex};`"></div>
                  <div>
                    <div class="flex gap-2 items-baseline">
                      <span class="font-medium" x-text="d.label"></span>
                    </div>
                    <div class="text-xs text-slate-400 metric-row">
                      <span class="metric-chip">
                        <span class="nf">󰋱</span>
                        <span><span x-text="d.u.toFixed(2)"></span>×<span x-text="d.v.toFixed(2)"></span></span>
                      </span>
                      <span class="metric-chip">
                        <span class="nf">󰺖</span>
                        <span x-text="`${d.w|0}×${d.h|0}`"></span>
                      </span>
                      <span class="metric-chip">
                        <span class="nf">󰆋</span>
                        <span x-text="d.azLabel"></span>
                        <span>·</span>
                        <span x-text="d.azDeg.toFixed(0) + '°'"></span>
                      </span>
                      <span class="metric-chip">
                        <span class="nf">󰄨</span>
                        <span x-text="d.score.toFixed(2)"></span>
                      </span>
                    </div>
                  </div>
                </div>
              </template>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="attribution">Map data © <a class="underline"
      href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors</div>

  <canvas id="scene"></canvas>
  <canvas id="tileCanvas" width="1280" height="1280"></canvas>

  <script type="module">
    import * as THREE from 'three';
    import {OrbitControls} from 'https://unpkg.com/three@0.180.0/examples/jsm/controls/OrbitControls.js';

    // ----- Colors -----
    const CAMERA_GREEN = 0x4ade80;  // lime green indicator
    const CAMERA_ORANGE = 0xf6c560;  // frustum / bearing indicator
    const CAMERA_YAW_OFFSET = Math.PI; // ensures yaw=0 aligns with map north
    const YELLOW = 0xfacc15;  // yellow caret + "N"
    const BLUE_GLYPH = 0x89b4fa;  // light blue (reuse from previous glyph)

    const hexToCss = (hex) => `#${hex.toString(16).padStart(6, '0')}`;

    // ----- 3D dial helpers -----
    function makeCircle(radius, segments = 256, color = CAMERA_GREEN, width = 2) {
      const pts = []; for (let i = 0; i <= segments; i++) {const t = (i / segments) * Math.PI * 2; pts.push(new THREE.Vector3(Math.cos(t) * radius, 0, Math.sin(t) * radius));}
      const geo = new THREE.BufferGeometry().setFromPoints(pts);
      return new THREE.Line(geo, new THREE.LineBasicMaterial({color, linewidth: width, depthTest: true, depthWrite: false}));
    }
    function makeTicks(radius, stepDeg = 5, color = CAMERA_GREEN) {
      const positions = [];
      for (let deg = 0; deg < 360; deg += stepDeg) {
        const is30 = deg % 30 === 0, is10 = deg % 10 === 0, len = is30 ? 1.8 : is10 ? 1.2 : 0.6;
        const a = THREE.MathUtils.degToRad(deg), cx = Math.cos(a), sz = Math.sin(a), r1 = radius - len, r2 = radius;
        positions.push(r1 * cx, 0, r1 * sz, r2 * cx, 0, r2 * sz);
      }
      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      return new THREE.LineSegments(geo, new THREE.LineBasicMaterial({color, depthTest: true, depthWrite: false}));
    }
    function makeTextPlane(text, scale = 3, color = CAMERA_GREEN, bold = false) {
      const cw = 256, ch = 128, c = document.createElement('canvas'); c.width = cw; c.height = ch; const ctx = c.getContext('2d', {willReadFrequently: true});
      ctx.clearRect(0, 0, cw, ch);
      ctx.fillStyle = typeof color === 'number' ? hexToCss(color) : color;
      ctx.font = `${bold ? '700' : '600'} 72px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto`;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(text, cw / 2, ch / 2);
      const tex = new THREE.CanvasTexture(c); tex.colorSpace = THREE.SRGBColorSpace; tex.transparent = true;
      const aspect = cw / ch, height = scale, width = height * aspect;
      const m = new THREE.Mesh(new THREE.PlaneGeometry(width, height), new THREE.MeshBasicMaterial({map: tex, transparent: true, depthTest: true, depthWrite: false}));
      return m;
    }

    const TMP_CENTER = new THREE.Vector3();
    const TMP_LOCAL = new THREE.Vector3();

    function createRadialLabel({text, radius, angleRad, scale, color, bold = false, height = 0.01}) {
      const pivot = new THREE.Object3D();
      pivot.rotation.y = Math.PI / 2 - angleRad;

      const mesh = makeTextPlane(text, scale, color, bold);
      mesh.position.set(0, height, radius);
      mesh.rotation.set(Math.PI / 2, Math.PI, Math.PI);
      pivot.add(mesh);

      return {pivot, mesh};
    }

    function makeAzimuthDial({scene, center, radius = 22, y = 2}) {
      const g = new THREE.Group(); g.position.set(center.x, y, center.z);

      const dial = new THREE.Group();

      const INDICATOR_RADIUS = radius - 1.2;
      const INDICATOR_HEIGHT = 0.9;

      const bearingSphere = new THREE.Mesh(
        new THREE.SphereGeometry(2.2, 24, 18),
        new THREE.MeshBasicMaterial({color: CAMERA_ORANGE})
      );
      bearingSphere.position.set(0, INDICATOR_HEIGHT, INDICATOR_RADIUS);
      dial.add(bearingSphere);

      const detectionRoot = new THREE.Group();
      dial.add(detectionRoot);
      const detectionSphereGeo = new THREE.SphereGeometry(1.4, 16, 12);
      const detectionSphereMat = new THREE.MeshBasicMaterial({color: CAMERA_GREEN});
      const detectionLineMat = new THREE.LineBasicMaterial({color: CAMERA_GREEN, depthTest: true, depthWrite: false});
      const detectionLines = [];

      const originAnchor = new THREE.Object3D();
      dial.add(originAnchor);

      const cameraLineGeo = new THREE.BufferGeometry();
      const cameraLineMat = new THREE.LineBasicMaterial({color: CAMERA_ORANGE, depthTest: true, depthWrite: false});
      const cameraLine = new THREE.Line(cameraLineGeo, cameraLineMat);
      cameraLineGeo.setFromPoints([originAnchor.position, originAnchor.position]);
      dial.add(cameraLine);

      // Rings / ticks — camera green
      dial.add(makeCircle(radius, 256, CAMERA_GREEN, 2));
      dial.add(makeCircle(radius - 2.4, 256, CAMERA_GREEN, 1));
      dial.add(makeTicks(radius, 5, CAMERA_GREEN));

      // Degree numbers — 2x larger, tucked inside the ring and rotated to read from the rig outward
      for (let deg = 0; deg < 360; deg += 30) {
        const angle = THREE.MathUtils.degToRad(deg), rr = radius - 3.6;
        const {pivot} = createRadialLabel({text: String(deg), radius: rr, angleRad: angle, scale: 4.8, color: CAMERA_GREEN, bold: false, height: 0.01});
        dial.add(pivot);
      }

      // Cardinals — 3x larger; pushed further OUT (double previous push) and sharing the same outward-facing rotation
      const cards = [['N', 0, YELLOW], ['E', 90, CAMERA_GREEN], ['S', 180, CAMERA_GREEN], ['W', 270, CAMERA_GREEN]];
      const CARDINAL_PUSH = 2.4; // double previous 1.2
      for (const [t, deg, col] of cards) {
        const angle = THREE.MathUtils.degToRad(deg);
        const rr = radius + CARDINAL_PUSH; // outside the ring to avoid overlap
        const {pivot} = createRadialLabel({text: t, radius: rr, angleRad: angle, scale: 9.6, color: col, bold: true, height: 0.02});
        dial.add(pivot);
      }

      // Yellow North caret (points along +Z)
      const caretGeo = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, radius + 1.2),
        new THREE.Vector3(0, 0, radius - 1.5)
      ]);
      const caret = new THREE.Line(caretGeo, new THREE.LineBasicMaterial({color: YELLOW, linewidth: 2}));

      // Keep your previous transforms
      g.rotation.y = Math.PI;
      dial.rotation.y = -Math.PI / 2;

      g.add(dial, caret);
      scene.add(g);

      const setCameraBearingFromPoint = (worldPoint) => {
        if (!worldPoint) return;
        dial.updateWorldMatrix(true, false);
        TMP_LOCAL.copy(worldPoint);
        dial.worldToLocal(TMP_LOCAL);
        TMP_LOCAL.y = 0;
        const len = TMP_LOCAL.length();
        if (len < 1e-6) return;
        const scale = INDICATOR_RADIUS / len;
        bearingSphere.position.set(TMP_LOCAL.x * scale, INDICATOR_HEIGHT, TMP_LOCAL.z * scale);
        cameraLineGeo.setFromPoints([originAnchor.position, bearingSphere.position]);
        cameraLineGeo.computeBoundingSphere();
      };

      const setDetectionPoints = (points) => {
        dial.updateWorldMatrix(true, false);
        while (detectionRoot.children.length) {
          const child = detectionRoot.children.pop();
          detectionRoot.remove(child);
        }
        for (const line of detectionLines) {line.geometry.dispose(); dial.remove(line);}
        detectionLines.length = 0;
        if (!points) return;
        for (const point of points) {
          if (!point) continue;
          TMP_LOCAL.copy(point);
          dial.worldToLocal(TMP_LOCAL);
          TMP_LOCAL.y = 0;
          const len = TMP_LOCAL.length();
          if (len < 1e-6) continue;
          const scale = INDICATOR_RADIUS / len;
          const sphere = new THREE.Mesh(detectionSphereGeo, detectionSphereMat);
          sphere.position.set(TMP_LOCAL.x * scale, INDICATOR_HEIGHT, TMP_LOCAL.z * scale);
          detectionRoot.add(sphere);
          const lineGeo = new THREE.BufferGeometry().setFromPoints([originAnchor.position, sphere.position]);
          const line = new THREE.Line(lineGeo, detectionLineMat);
          dial.add(line);
          detectionLines.push(line);
        }
      };

      return {group: g, setCameraBearingFromPoint, setDetectionPoints};
    }

    // Map UV -> world on live-feed plane
    function uvToWorldOnScreen(screen, feedW, feedH, u, v) {
      const local = new THREE.Vector3((u - 0.5) * feedW, (0.5 - v) * feedH, 0);
      return local.applyMatrix4(screen.matrixWorld);
    }

    // bbox center to normalized [0..1] UV
    function bboxToCenterUV(bb, imgW, imgH) {
      const clamp01 = t => Math.min(1, Math.max(0, t));
      if (bb && typeof bb === 'object' && !Array.isArray(bb)) {
        if (('x1' in bb && 'y1' in bb && 'x2' in bb && 'y2' in bb) || ('left' in bb && 'top' in bb && 'right' in bb && 'bottom' in bb)) {
          const x1 = bb.x1 ?? bb.left, y1 = bb.y1 ?? bb.top, x2 = bb.x2 ?? bb.right, y2 = bb.y2 ?? bb.bottom;
          const norm = x1 <= 1 && y1 <= 1 && x2 <= 1 && y2 <= 1;
          return [clamp01(((x1 + x2) * 0.5) / (norm ? 1 : imgW)), clamp01(((y1 + y2) * 0.5) / (norm ? 1 : imgH))];
        }
        if (('x' in bb && 'y' in bb && ('w' in bb || 'width' in bb) && ('h' in bb || 'height' in bb))) {
          const x = bb.x ?? bb.left ?? 0, y = bb.y ?? bb.top ?? 0, w = bb.w ?? bb.width ?? 0, h = bb.h ?? bb.height ?? 0;
          const norm = x <= 1 && y <= 1 && w <= 1 && h <= 1;
          return [clamp01((x + w * 0.5) / (norm ? 1 : imgW)), clamp01((y + h * 0.5) / (norm ? 1 : imgH))];
        }
      }
      if (Array.isArray(bb) && bb.length === 4) {
        const [a, b, c, d] = bb, looksXYXYpx = (a < c) && (b < d) && (c <= imgW + 1) && (d <= imgH + 1);
        if (looksXYXYpx) return [clamp01((a + c) * 0.5 / imgW), clamp01((b + d) * 0.5 / imgH)];
        const looksXYXYnorm = (a <= 1 && b <= 1 && c <= 1 && d <= 1) && (a < c) && (b < d);
        if (looksXYXYnorm) return [clamp01((a + c) * 0.5), clamp01((b + d) * 0.5)];
        const norm = a <= 1 && b <= 1 && c <= 1 && d <= 1;
        return [clamp01((a + c * 0.5) / (norm ? 1 : imgW)), clamp01((b + d * 0.5) / (norm ? 1 : imgH))];
      }
      return [0.5, 0.5];
    }

    // ---------- map ----------
    const d2r = d => d * Math.PI / 180;
    const MAP_CORRECTION_WORLD = {x: -1.1, z: -63.7}; // applied to rig placement so map stays centered
    function latLonToTileXY(lat, lon, z) {const x = Math.floor((lon + 180) / 360 * Math.pow(2, z)); const y = Math.floor((1 - Math.log(Math.tan(d2r(lat)) + 1 / Math.cos(d2r(lat))) / Math.PI) / 2 * Math.pow(2, z)); return {x, y};}
    async function buildTilePatch({lat, lon}, zoom = 16) {
      const txFloat = ((lon + 180) / 360) * Math.pow(2, zoom);
      const tyFloat = (0.5 - Math.log((1 + Math.sin(d2r(lat))) / (1 - Math.sin(d2r(lat)))) / (4 * Math.PI)) * Math.pow(2, zoom);
      const cx = Math.floor(txFloat), cy = Math.floor(tyFloat);
      const fx = txFloat - cx, fy = tyFloat - cy;
      const tileSize = 256, tileRadius = 2, baseGrid = tileRadius * 2 + 1;
      const canvas = document.getElementById('tileCanvas'); canvas.width = tileSize * baseGrid; canvas.height = tileSize * baseGrid;
      const ctx = canvas.getContext('2d', {willReadFrequently: true}); let ok = 0; const loads = [];
      const shiftX = (canvas.width * 0.5) - ((tileRadius + fx) * tileSize);
      const shiftY = (canvas.height * 0.5) - ((tileRadius + fy) * tileSize);
      let minDx = -tileRadius, maxDx = tileRadius;
      let minDy = -tileRadius, maxDy = tileRadius;
      let coverageLeft = shiftX + (minDx + tileRadius) * tileSize;
      while (coverageLeft > 0) {minDx--; coverageLeft -= tileSize;}
      let coverageRight = shiftX + (maxDx + tileRadius + 1) * tileSize;
      while (coverageRight < canvas.width) {maxDx++; coverageRight += tileSize;}
      let coverageTop = shiftY + (minDy + tileRadius) * tileSize;
      while (coverageTop > 0) {minDy--; coverageTop -= tileSize;}
      let coverageBottom = shiftY + (maxDy + tileRadius + 1) * tileSize;
      while (coverageBottom < canvas.height) {maxDy++; coverageBottom += tileSize;}
      ctx.save();
      ctx.fillStyle = '#0b0f14';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.translate(shiftX, shiftY);
      for (let dy = minDy; dy <= maxDy; dy++) for (let dx = minDx; dx <= maxDx; dx++) {
        const url = `https://tile.openstreetmap.org/${zoom}/${cx + dx}/${cy + dy}.png`;
        loads.push(new Promise(res => {
          const img = new Image(); img.crossOrigin = 'anonymous';
          img.onload = () => {ctx.drawImage(img, (dx + tileRadius) * tileSize, (dy + tileRadius) * tileSize); ok++; res();};
          img.onerror = () => res(); img.src = url;
        }));
      }
      await Promise.all(loads);
      ctx.restore();
      if (!ok) throw new Error('No tiles loaded');
      return canvas;
    }

    function latLonToGlobalPixels(lat, lon, zoom) {
      const scale = 256 * Math.pow(2, zoom);
      const x = ((lon + 180) / 360) * scale;
      const sinLat = Math.sin(d2r(lat));
      const y = (0.5 - Math.log((1 + sinLat) / (1 - sinLat)) / (4 * Math.PI)) * scale;
      return {x, y};
    }

    // ---------- MJPEG ----------
    class MJPEGTexture {
      constructor(url) {
        this.url = url; this.canvas = document.createElement('canvas'); this.ctx = this.canvas.getContext('2d', {willReadFrequently: true});
        this.texture = new THREE.CanvasTexture(this.canvas); this._setupTex(this.texture);
        this.ok = false; this.fps = 0; this._frames = 0; this._last = performance.now(); this._w = 0; this._h = 0; this._consumers = new Set();
      }
      _setupTex(tex) {tex.colorSpace = THREE.SRGBColorSpace; tex.minFilter = THREE.LinearFilter; tex.magFilter = THREE.LinearFilter; tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping; tex.flipY = true; tex.needsUpdate = true;}
      attach(material) {material.map = this.texture; material.needsUpdate = true; this._consumers.add(material);}
      _recreateTextureForSize(w, h) {
        const c = document.createElement('canvas'); c.width = w; c.height = h; this.canvas = c; this.ctx = c.getContext('2d', {willReadFrequently: true});
        const old = this.texture; this.texture = new THREE.CanvasTexture(this.canvas); this._setupTex(this.texture); if (old) old.dispose();
        for (const m of this._consumers) {m.map = this.texture; m.needsUpdate = true;}
      }
      async start(onStatus) {
        try {
          const resp = await fetch(this.url, {mode: 'cors'}); if (!resp.body) throw new Error('no body'); const reader = resp.body.getReader();
          let buf = new Uint8Array(0); const SOI = [0xFF, 0xD8], EOI = [0xFF, 0xD9];
          const find = (b, m) => {for (let i = 0; i < b.length - 1; i++) if (b[i] === m[0] && b[i + 1] === m[1]) return i; return -1;};
          this.ok = true; onStatus?.(this);
          while (true) {
            const {value, done} = await reader.read(); if (done) break; if (!value) continue;
            const tmp = new Uint8Array(buf.length + value.length); tmp.set(buf); tmp.set(value, buf.length); buf = tmp;
            while (true) {
              const s = find(buf, SOI), e = find(buf, EOI);
              if (s >= 0 && e > s) {
                const frame = buf.slice(s, e + 2); buf = buf.slice(e + 2);
                try {
                  const bmp = await createImageBitmap(new Blob([frame], {type: 'image/jpeg'}), {imageOrientation: 'from-image'});
                  const w = bmp.width | 0, h = bmp.height | 0; if (!w || !h) continue;
                  if (w !== this._w || h !== this._h) {this._w = w; this._h = h; this._recreateTextureForSize(w, h);}
                  this.ctx.drawImage(bmp, 0, 0, this._w, this._h); this.texture.needsUpdate = true;
                  this._frames++; const now = performance.now();
                  if (now - this._last > 1000) {this.fps = (this._frames * 1000) / (now - this._last); this._frames = 0; this._last = now; onStatus?.(this);}
                } catch { }
              } else break;
            }
          }
        } catch {
          this.ok = false; this.fps = 0; onStatus?.(this);
        }
      }
    }

    // ---------- Three bootstrap ----------
    function bootScene(hooks) {
      const canvas = document.getElementById('scene');
      const renderer = new THREE.WebGLRenderer({canvas, antialias: true});
      renderer.setPixelRatio(window.devicePixelRatio || 1);

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0b0f14);

      const camera = new THREE.PerspectiveCamera(60, 2, 0.1, 2000);
      camera.position.set(0, 160, 260);

      const controls = new OrbitControls(camera, renderer.domElement);

      // Recommended OrbitControls setup for smooth, predictable zoom on all devices
      controls.enableDamping = true;
      controls.dampingFactor = 0.1;

      controls.enableZoom = true;
      controls.zoomSpeed = 1.0;          // standard speed
      controls.zoomToCursor = false;      // avoids jumpy zoom on some desktop wheels
      controls.enablePan = true;
      controls.panSpeed = 1.0;

      // Explicit mouse/touch mappings (Three.js defaults, but set explicitly for consistency)
      controls.mouseButtons = {
        LEFT: THREE.MOUSE.ROTATE,
        MIDDLE: THREE.MOUSE.DOLLY,
        RIGHT: THREE.MOUSE.PAN
      };
      controls.touches = {
        ONE: THREE.TOUCH.ROTATE,
        TWO: THREE.TOUCH.DOLLY_PAN
      };

      // Useful bounds to avoid hitting extremes
      controls.minDistance = 20;
      controls.maxDistance = 1200;

      controls.screenSpacePanning = true;

      controls.listenToKeyEvents(window); // ensures keyboard works consistently
      controls.update();

      scene.add(new THREE.HemisphereLight(0xbcd1ff, 0x232b35, 0.6));
      const dir = new THREE.DirectionalLight(0xffffff, 0.9);
      dir.position.set(80, 120, 60);
      scene.add(dir);

      function resize() {
        const w = window.innerWidth, h = window.innerHeight;
        camera.aspect = w / h; camera.updateProjectionMatrix();
        renderer.setSize(w, h, false);
      }
      addEventListener('resize', resize); resize();

      const clock = new THREE.Clock();
      (function tick() {
        hooks?.update?.(clock.getDelta());
        controls.update();
        renderer.render(scene, camera);
        requestAnimationFrame(tick);
      })();

      return {scene, camera, renderer, controls};
    }

    // ---------- Frustum fitted to the live-feed plane ----------
    function makeRigForScreen(scene, screen, opts = {}) {
      const fovDeg = opts.fovDeg ?? 50, far = opts.far ?? 60, color = opts.color ?? CAMERA_ORANGE;
      const p = screen.geometry.parameters, halfW = (p?.width ?? 1) * 0.5 * screen.scale.x, halfH = (p?.height ?? 1) * 0.5 * screen.scale.y;
      const center = new THREE.Vector3(); screen.getWorldPosition(center); const q = new THREE.Quaternion(); screen.getWorldQuaternion(q);
      const n = new THREE.Vector3(0, 0, 1).applyQuaternion(q).normalize(), right = new THREE.Vector3(1, 0, 0).applyQuaternion(q).normalize(), up = new THREE.Vector3(0, 1, 0).applyQuaternion(q).normalize();
      const cTL = center.clone().add(up.clone().multiplyScalar(halfH)).sub(right.clone().multiplyScalar(halfW));
      const cTR = center.clone().add(up.clone().multiplyScalar(halfH)).add(right.clone().multiplyScalar(halfW));
      const cBL = center.clone().sub(up.clone().multiplyScalar(halfH)).sub(right.clone().multiplyScalar(halfW));
      const cBR = center.clone().sub(up.clone().multiplyScalar(halfH)).add(right.clone().multiplyScalar(halfW));
      const dist = halfH / Math.tan(THREE.MathUtils.degToRad(fovDeg * 0.5)); const origin = center.clone().sub(n.clone().multiplyScalar(dist));
      const farCenter = origin.clone().add(n.clone().multiplyScalar(far)); const s = far / dist;
      const fTL = farCenter.clone().add(up.clone().multiplyScalar(halfH * s)).sub(right.clone().multiplyScalar(halfW * s));
      const fTR = farCenter.clone().add(up.clone().multiplyScalar(halfH * s)).add(right.clone().multiplyScalar(halfW * s));
      const fBL = farCenter.clone().sub(up.clone().multiplyScalar(halfH * s)).sub(right.clone().multiplyScalar(halfW * s));
      const fBR = farCenter.clone().sub(up.clone().multiplyScalar(halfH * s)).add(right.clone().multiplyScalar(halfW * s));

      const mat = new THREE.LineBasicMaterial({color, depthTest: true, depthWrite: false});
      const nearRect = new THREE.Line(new THREE.BufferGeometry().setFromPoints([cTL, cTR, cBR, cBL, cTL]), mat);
      const farRect = new THREE.Line(new THREE.BufferGeometry().setFromPoints([fTL, fTR, fBR, fBL, fTL]), mat);
      const edges = new THREE.LineSegments(new THREE.BufferGeometry().setFromPoints([origin, cTL, origin, cTR, origin, cBL, origin, cBR]), mat);

      // Replace glyph with a single blue vertical line from camera origin down to ground
      const cameraDownGeo = new THREE.BufferGeometry().setFromPoints([
        origin.clone(),
        new THREE.Vector3(origin.x, 0, origin.z)
      ]);
      const cameraDown = new THREE.Line(cameraDownGeo, new THREE.LineBasicMaterial({color: BLUE_GLYPH, linewidth: 2}));

      const normalLine = new THREE.Line(new THREE.BufferGeometry().setFromPoints([center, origin]), new THREE.LineDashedMaterial({color, dashSize: 2, gapSize: 1})); normalLine.computeLineDistances();

      const group = new THREE.Group();
      group.add(nearRect, edges, cameraDown, normalLine); //farRect, 
      scene.add(group);
      return {group, origin};
    }

    // ---------- Alpine app ----------
    window.hud = () => ({
      geo: {ok: true, lat: 45.81320316151337, lon: 15.977304294939904},
      map: {ready: false, mesh: null, zoom: 16},
      stream: {ok: false, fps: 0},
      loading: {active: true, progress: 0, label: 'Initializing HUD...'},
      loadingTimer: null,
      panelCollapsed: false,
      sections: {preview: true, status: true, detections: true},
      previewMode: 'original',
      preview: {canvas: null, ctx: null, prev: null, raf: null, threshold: 20, overlayAlpha: 0.6, buffers: {}, lastRender: 0},
      three: null, mjpeg: null, frustumVisible: true,

      cameras: [],
      activeCameraId: null,
      screen: null,
      rig: null,
      feed: {w: 80, h: 60},
      cameraYaw: 0.0,
      raycaster: null,
      pointer: null,
      azimuth: null,

      detLines: null,      // line group
      detDots: null,       // dot group
      detMat: null,        // stable line material
      uiDetections: [],
      sse: null,

      setLoading(progress, label) {
        if (typeof progress === 'number' && !Number.isNaN(progress)) {
          this.loading.progress = Math.max(0, Math.min(100, progress));
        }
        if (label) this.loading.label = label;
      },

      latLonToWorld(lat, lon) {
        const transform = this.map.transform;
        if (!transform) return {x: 0, z: 0};
        const px = latLonToGlobalPixels(lat, lon, this.map.zoom ?? 16);
        const dxPx = px.x - transform.centerPx.x;
        const dzPx = px.y - transform.centerPx.y;
        return {
          x: dxPx * transform.pxToWorldX,
          z: -dzPx * transform.pxToWorldZ
        };
      },

      finishLoading({delay = 300, label} = {}) {
        if (!this.loading.active) return;
        if (this.loadingTimer) {clearTimeout(this.loadingTimer); this.loadingTimer = null;}
        const readyLabel = label ?? (this.stream.ok ? 'HUD Ready' : 'HUD Ready (stream offline)');
        this.setLoading(100, readyLabel);
        setTimeout(() => {this.loading.active = false;}, delay);
      },

      scheduleLoadingFallback(delay = 3500, label = 'HUD Ready (awaiting stream)') {
        if (this.loadingTimer) clearTimeout(this.loadingTimer);
        this.loadingTimer = setTimeout(() => {
          if (!this.loading.active) return;
          this.finishLoading({delay: 0, label});
        }, delay);
      },

      togglePanel() {
        this.panelCollapsed = !this.panelCollapsed;
        if (this.panelCollapsed) {
          this.stopPreviewLoop();
          if (this.preview.ctx && this.preview.canvas) {
            this.preview.ctx.clearRect(0, 0, this.preview.canvas.width || 0, this.preview.canvas.height || 0);
            this.preview.ctx.fillStyle = '#000';
            this.preview.ctx.fillRect(0, 0, this.preview.canvas.width || 0, this.preview.canvas.height || 0);
          }
        } else if (this.sections.preview) {
          this.preview.prev = null;
          this.startPreviewLoop();
        }
      },

      toggleSection(section) {
        if (!(section in this.sections)) return;
        const currentlyOpen = this.sections[section];
        this.sections[section] = !currentlyOpen;
        if (section === 'preview') {
          if (this.sections.preview && !this.panelCollapsed) {
            this.preview.prev = null;
            this.startPreviewLoop();
          } else {
            this.stopPreviewLoop();
            if (this.preview.ctx && this.preview.canvas) {
              this.preview.ctx.clearRect(0, 0, this.preview.canvas.width || 0, this.preview.canvas.height || 0);
              this.preview.ctx.fillStyle = '#000';
              this.preview.ctx.fillRect(0, 0, this.preview.canvas.width || 0, this.preview.canvas.height || 0);
            }
          }
        }
      },

      setPreviewMode(mode) {
        if (!mode) return;
        if (mode === this.previewMode) return;
        this.previewMode = mode;
        this.preview.prev = null; // reset baseline so diff recalculates cleanly
      },

      initLivePreview() {
        this.$nextTick(() => {
          const canvas = this.$refs.previewCanvas;
          if (!canvas) return;
          this.preview.canvas = canvas;
          this.preview.ctx = canvas.getContext('2d', {willReadFrequently: true});
          this.preview.prev = null;
          this.preview.buffers = {};
          this.preview.lastRender = 0;
          if (!this.panelCollapsed && this.sections.preview) {
            this.startPreviewLoop();
          }
        });
      },

      startPreviewLoop() {
        if (this.panelCollapsed || !this.sections.preview) return;
        if (this.preview.raf) return;
        const tick = () => {
          if (this.panelCollapsed || !this.sections.preview) {
            this.preview.raf = null;
            return;
          }
          this.renderPreview();
          this.preview.raf = requestAnimationFrame(tick);
        };
        this.preview.raf = requestAnimationFrame(tick);
      },

      stopPreviewLoop() {
        if (this.preview.raf) cancelAnimationFrame(this.preview.raf);
        this.preview.raf = null;
        this.preview.lastRender = 0;
      },

      ensurePreviewBuffer(name, w, h) {
        const buffers = this.preview.buffers || (this.preview.buffers = {});
        let buf = buffers[name];
        if (!buf || buf.width !== w || buf.height !== h) {
          buf = this.preview.ctx.createImageData(w, h);
          buffers[name] = buf;
        }
        return buf;
      },

      renderPreview() {
        const canvas = this.preview.canvas;
        const ctx = this.preview.ctx;
        const mjpeg = this.mjpeg;
        if (this.panelCollapsed || !this.sections.preview) return;
        if (!canvas || !ctx || !mjpeg || !mjpeg.canvas || !mjpeg.ctx) return;

        const now = performance.now();
        const minInterval = this.previewMode === 'overlay' ? 80 : 45; // throttle heavy modes
        if (now - (this.preview.lastRender ?? 0) < minInterval) return;
        this.preview.lastRender = now;

        const sourceCanvas = mjpeg.canvas;
        const sourceCtx = mjpeg.ctx;
        const w = mjpeg._w || sourceCanvas.width;
        const h = mjpeg._h || sourceCanvas.height;
        if (!w || !h) return;

        if (canvas.width !== w || canvas.height !== h) {
          canvas.width = w;
          canvas.height = h;
        }

        let curr;
        try {
          curr = sourceCtx.getImageData(0, 0, w, h);
        } catch {
          return;
        }

        if (!this.preview.prev) {
          ctx.drawImage(sourceCanvas, 0, 0, w, h);
          this.preview.prev = curr;
          return;
        }

        const prev = this.preview.prev;
        const currData = curr.data;
        const prevData = prev.data;
        const length = currData.length;
        const threshold = this.preview.threshold;
        const overlayAlpha = this.preview.overlayAlpha;

        if (this.previewMode === 'original') {
          ctx.drawImage(sourceCanvas, 0, 0, w, h);
        } else if (this.previewMode === 'delta') {
          const deltaImage = this.ensurePreviewBuffer('delta', w, h);
          const out = deltaImage.data;
          for (let i = 0; i < length; i += 4) {
            const dr = currData[i] - prevData[i];
            const dg = currData[i + 1] - prevData[i + 1];
            const db = currData[i + 2] - prevData[i + 2];
            out[i] = Math.max(0, Math.min(255, 128 + dr));
            out[i + 1] = Math.max(0, Math.min(255, 128 + dg));
            out[i + 2] = Math.max(0, Math.min(255, 128 + db));
            out[i + 3] = 255;
          }
          ctx.putImageData(deltaImage, 0, 0);
        } else if (this.previewMode === 'abs') {
          const diffImage = this.ensurePreviewBuffer('diff', w, h);
          const out = diffImage.data;
          for (let i = 0; i < length; i += 4) {
            const dr = currData[i] - prevData[i];
            const dg = currData[i + 1] - prevData[i + 1];
            const db = currData[i + 2] - prevData[i + 2];
            let mag = (Math.abs(dr) + Math.abs(dg) + Math.abs(db)) / 3;
            if (mag < threshold) mag = 0;
            if (mag === 0) {
              out[i] = out[i + 1] = out[i + 2] = 0;
            } else {
              out[i] = 255;
              out[i + 1] = Math.min(255, 80 + mag * 1.1);
              out[i + 2] = 0;
            }
            out[i + 3] = 255;
          }
          ctx.putImageData(diffImage, 0, 0);
        } else {
          const overlayImage = this.ensurePreviewBuffer('overlay', w, h);
          const ov = overlayImage.data;
          for (let i = 0; i < length; i += 4) {
            const dr = currData[i] - prevData[i];
            const dg = currData[i + 1] - prevData[i + 1];
            const db = currData[i + 2] - prevData[i + 2];
            let mag = (Math.abs(dr) + Math.abs(dg) + Math.abs(db)) / 3;
            if (mag < threshold) mag = 0;
            const rr = 255;
            const gg = Math.min(255, 120 + mag * 1.5);
            const bb = 0;
            const alpha = mag === 0 ? 0 : Math.round((mag / 255) * overlayAlpha * 255);
            ov[i] = rr;
            ov[i + 1] = gg;
            ov[i + 2] = bb;
            ov[i + 3] = alpha;
          }
          ctx.putImageData(overlayImage, 0, 0);
        }

        this.preview.prev = curr;
      },

      async init() {
        this.setLoading(5, 'Booting renderer');
        this.three = bootScene({update: () => { }});
        this.three.camera.lookAt(0, 0, 0);

        this.setLoading(20, 'Acquiring location');
        await this.acquireLocation();

        this.setLoading(45, 'Loading map tiles');
        await this.loadMapPlane();

        this.setLoading(60, 'Preparing video stream');
        this.mjpeg = new MJPEGTexture('http://127.0.0.1:8080/stream.mjpg');
        this.mjpeg.start(s => {
          this.stream.ok = s.ok; this.stream.fps = s.fps;
          if (s.ok && this.loading.active) {
            this.setLoading(Math.max(this.loading.progress, 95), 'Video stream ready');
            this.finishLoading();
          }
        });

        const feedW = 80, feedH = 60; this.feed = {w: feedW, h: feedH};
        this.raycaster = new THREE.Raycaster();
        this.pointer = new THREE.Vector2();
        this.three.renderer.domElement.addEventListener('pointerdown', e => this.handlePointerDown(e));
        this.rebuildCameras();

        this.setLoading(75, 'Aligning frustum');

        this.setCameraYaw(this.cameraYaw);

        this.detLines = new THREE.Group(); this.three.scene.add(this.detLines);
        this.detDots = new THREE.Group(); this.three.scene.add(this.detDots);
        this.detMat = new THREE.LineBasicMaterial({color: CAMERA_GREEN, depthTest: true, depthWrite: false});

        this.initLivePreview();
        window.addEventListener('beforeunload', () => this.stopPreviewLoop());

        this.setLoading(85, 'Subscribing detections');
        try {
          this.sse = new EventSource('http://127.0.0.1:8080/stream_detections');
          this.sse.onmessage = (ev) => {if (!ev.data) return; try {this.handleDetections(JSON.parse(ev.data));} catch { } };
          this.sse.onerror = () => { };
        } catch { }
        if (this.stream.ok) {
          this.finishLoading();
        } else {
          this.setLoading(Math.max(this.loading.progress, 90), 'Waiting for video stream...');
          this.scheduleLoadingFallback();
        }
      },

      // score -> hex: 0(red) -> 0.5(yellow) -> 1(green)
      scoreToHex(s) {
        const clamped = Math.max(0, Math.min(1, s ?? 0.5));
        const h = clamped * 120; // 0..120
        const c = new THREE.Color().setHSL(h / 360, 0.9, 0.55);
        return `#${c.getHexString()}`;
      },

      handleDetections(msg) {
        const active = this.getActiveCamera();
        if (!active?.screen || !active?.rig) return;
        const screen = active.screen;
        const rig = active.rig;

        const imgW = msg.width ?? msg.image_width ?? this.mjpeg?._w ?? 1;
        const imgH = msg.height ?? msg.image_height ?? this.mjpeg?._h ?? 1;

        const boxes = (msg.detections ?? msg.boxes ?? msg.objects ?? [])
          .filter(d => (d.class ?? d.label ?? 'FACE') === 'FACE');

        // Clear previous frame primitives
        while (this.detLines.children.length) {const c = this.detLines.children.pop(); c.geometry?.dispose?.();}
        while (this.detDots.children.length) {const c = this.detDots.children.pop(); c.geometry?.dispose?.(); c.material?.dispose?.();}

        const ui = [];
        const detectionPoints = [];

        for (const det of boxes) {
          const bb = det.bbox ?? det;
          const [u, v] = bboxToCenterUV(bb, imgW, imgH);
          const hit = uvToWorldOnScreen(screen, this.feed.w, this.feed.h, u, v);

          // Stable line
          const lineGeo = new THREE.BufferGeometry().setFromPoints([rig.origin.clone(), hit]);
          this.detLines.add(new THREE.Line(lineGeo, this.detMat));

          // Score-colored dot
          const dotGeo = new THREE.SphereGeometry(0.7, 12, 12);
          const dotMat = new THREE.MeshBasicMaterial({color: this.scoreToHex(det.score ?? 0.5)});
          const dot = new THREE.Mesh(dotGeo, dotMat); dot.position.copy(hit); this.detDots.add(dot);

          detectionPoints.push(hit);

          // UI item
          let wPx = 0, hPx = 0;
          if (Array.isArray(bb) && bb.length === 4) {wPx = Math.abs(bb[2] - bb[0]); hPx = Math.abs(bb[3] - bb[1]);}
          else if ('right' in bb && 'left' in bb && 'bottom' in bb && 'top' in bb) {wPx = Math.abs(bb.right - bb.left); hPx = Math.abs(bb.bottom - bb.top);}
          else if ('w' in bb || 'width' in bb) {wPx = Math.abs(bb.w ?? bb.width ?? 0); hPx = Math.abs(bb.h ?? bb.height ?? 0);}

          const score = det.score ?? 0;
          let azDeg = 0, azLabel = 'N';
          if (rig?.origin) {
            const dx = hit.x - rig.origin.x;
            const dz = hit.z - rig.origin.z;
            const angRad = Math.atan2(dx, dz); // +Z is north
            azDeg = (540 - THREE.MathUtils.radToDeg(angRad)) % 360;
            if (azDeg < 0) azDeg += 360;
            const dirs = [
              {label: 'N', deg: 0},
              {label: 'NE', deg: 45},
              {label: 'E', deg: 90},
              {label: 'SE', deg: 135},
              {label: 'S', deg: 180},
              {label: 'SW', deg: 225},
              {label: 'W', deg: 270},
              {label: 'NW', deg: 315}
            ];
            let best = dirs[0], bestDiff = 360;
            for (const dir of dirs) {
              let diff = Math.abs(dir.deg - azDeg);
              if (diff > 180) diff = 360 - diff;
              if (diff < bestDiff) {bestDiff = diff; best = dir;}
            }
            azLabel = best.label;
          }
          ui.push({
            key: `${u.toFixed(3)}:${v.toFixed(3)}:${score.toFixed(2)}`,
            label: det.class ?? det.label ?? 'FACE',
            score,
            u, v, w: wPx, h: hPx,
            hex: this.scoreToHex(score),
            azDeg,
            azLabel
          });
        }

        this.uiDetections = ui;
        this.azimuth?.setDetectionPoints?.(detectionPoints);
        this.updateCameraBearingSphere();
      },

      setCameraYaw(yawRad) {
        this.cameraYaw = yawRad;
        const active = this.getActiveCamera();
        if (active?.screen) {
          active.yawDeg = THREE.MathUtils.radToDeg(yawRad);
          active.screen.rotation.set(0, yawRad + CAMERA_YAW_OFFSET, 0);
        }
        this.updateCameraBearingSphere();
      },

      updateCameraBearingSphere() {
        if (!this.azimuth?.setCameraBearingFromPoint) return;
        const active = this.getActiveCamera();
        if (!active?.screen) return;
        active.screen.getWorldPosition(TMP_CENTER);
        this.azimuth.setCameraBearingFromPoint(TMP_CENTER);
      },

      destroyAzimuth() {
        if (!this.azimuth?.group) {this.azimuth = null; return;}
        if (this.three?.scene) this.three.scene.remove(this.azimuth.group);
        this.azimuth.group.traverse(obj => {
          obj.geometry?.dispose?.();
          if (obj.material && obj.material.isMaterial) obj.material.dispose();
        });
        this.azimuth = null;
      },

      disposeCameraEntry(entry) {
        if (!entry) return;
        if (entry.screen) {
          this.three?.scene?.remove(entry.screen);
          entry.screen.geometry?.dispose?.();
          entry.screen.material?.dispose?.();
        }
        if (entry.rig?.group) {
          this.three?.scene?.remove(entry.rig.group);
          entry.rig.group.traverse(obj => {
            obj.geometry?.dispose?.();
            if (obj.material && obj.material.isMaterial) obj.material.dispose();
          });
        }
        if (entry.sphere) {
          this.three?.scene?.remove(entry.sphere);
          entry.sphere.geometry?.dispose?.();
          entry.sphere.material?.dispose?.();
        }
      },

      createCameraEntry(cfg, index = 0) {
        if (!this.three?.scene || !this.mjpeg) return null;
        const rigOffset = MAP_CORRECTION_WORLD;
        const lift = this.feed.h * 0.5;
        const mat = new THREE.MeshBasicMaterial({
          side: THREE.DoubleSide,
          depthTest: true,
          depthWrite: true,
          toneMapped: false
        });
        this.mjpeg.attach(mat);
        const geom = new THREE.PlaneGeometry(this.feed.w, this.feed.h);
        const screen = new THREE.Mesh(geom, mat);
        const anchor = this.latLonToWorld(cfg.lat, cfg.lon);
        screen.position.set(
          anchor.x + (rigOffset?.x ?? 0),
          5 + lift,
          anchor.z + (rigOffset?.z ?? 0)
        );
        const yawDeg = cfg.yawDeg ?? 0;
        screen.rotation.set(0, THREE.MathUtils.degToRad(yawDeg) + CAMERA_YAW_OFFSET, 0);
        screen.renderOrder = 10 + index;
        screen.userData.cameraId = cfg.id;
        this.three.scene.add(screen);

        const rigColor = cfg.color ?? CAMERA_ORANGE;
        const rig = makeRigForScreen(this.three.scene, screen, {fovDeg: 50, far: 35, color: rigColor});
        rig.group.visible = this.frustumVisible;

        const sphereMat = new THREE.MeshStandardMaterial({
          color: rigColor,
          emissive: rigColor,
          emissiveIntensity: 0.18
        });
        const sphere = new THREE.Mesh(new THREE.SphereGeometry(3.2, 28, 24), sphereMat);
        sphere.position.set(rig.origin.x, rig.origin.y, rig.origin.z);
        sphere.userData.cameraId = cfg.id;
        sphere.renderOrder = screen.renderOrder + 1;
        this.three.scene.add(sphere);

        const entry = {id: cfg.id, lat: cfg.lat, lon: cfg.lon, yawDeg, color: rigColor, screen, rig, sphere};
        this.cameras.push(entry);
        return entry;
      },

      rebuildCameras() {
        if (!this.three?.scene || !this.mjpeg) return;
        for (const entry of this.cameras) this.disposeCameraEntry(entry);
        this.cameras = [];
        this.destroyAzimuth();
        const primaryId = 'cam-primary';
        const configs = [
          {id: primaryId, lat: this.geo.lat, lon: this.geo.lon, yawDeg: THREE.MathUtils.radToDeg(this.cameraYaw || 0), color: CAMERA_ORANGE},
          {id: 'cam-west', lat: 45.81331561028888, lon: 15.96973422476513, yawDeg: -45, color: 0x38bdf8},
          {id: 'cam-east', lat: 45.81635188042051, lon: 15.985263623730928, yawDeg: 120, color: 0xf97316}
        ];
        configs.forEach((cfg, idx) => this.createCameraEntry(cfg, idx));
        this.selectCamera(primaryId);
      },

      selectCamera(id) {
        const cam = this.cameras.find(c => c.id === id);
        if (!cam) return;
        this.activeCameraId = id;
        this.screen = cam.screen;
        this.rig = cam.rig;
        this.cameraYaw = THREE.MathUtils.degToRad(cam.yawDeg ?? 0);
        if (this.detLines) {
          while (this.detLines.children.length) {const child = this.detLines.children.pop(); child.geometry?.dispose?.(); this.detLines.remove(child);}
        }
        if (this.detDots) {
          while (this.detDots.children.length) {const child = this.detDots.children.pop(); child.geometry?.dispose?.(); child.material?.dispose?.(); this.detDots.remove(child);}
        }
        this.cameras.forEach(c => {
          if (c?.sphere?.material) {
            c.sphere.material.emissiveIntensity = c.id === id ? 0.65 : 0.15;
          }
        });
        this.destroyAzimuth();
        this.azimuth = makeAzimuthDial({
          scene: this.three.scene,
          center: new THREE.Vector3(cam.rig.origin.x, 0, cam.rig.origin.z),
          radius: 90,
          y: 2
        });
        this.updateCameraBearingSphere();
      },

      getActiveCamera() {
        if (this.activeCameraId) {
          const found = this.cameras.find(c => c.id === this.activeCameraId);
          if (found) return found;
        }
        return this.cameras[0] ?? null;
      },

      handlePointerDown(event) {
        if (!this.three?.renderer || !this.three?.camera) return;
        if (!this.raycaster || !this.pointer) return;
        if (event?.button !== undefined && event.button !== 0) return;
        const rect = this.three.renderer.domElement.getBoundingClientRect();
        const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        this.pointer.set(x, y);
        this.raycaster.setFromCamera(this.pointer, this.three.camera);
        const spheres = this.cameras.map(c => c.sphere).filter(Boolean);
        const hits = this.raycaster.intersectObjects(spheres, false);
        if (hits.length) {
          const targetId = hits[0].object.userData.cameraId;
          if (targetId) {
            event.stopPropagation?.();
            event.preventDefault?.();
            this.selectCamera(targetId);
          }
        }
      },

      async acquireLocation() {
        const params = new URLSearchParams(location.search);
        if (params.get('lat') && params.get('lon')) {
          this.geo.lat = parseFloat(params.get('lat'));
          this.geo.lon = parseFloat(params.get('lon'));
          this.geo.ok = true;
          return;
        }
        if (!this.geo.ok) {
          const p = new Promise(resolve => {
            if (!('geolocation' in navigator)) return resolve(false);
            navigator.geolocation.getCurrentPosition(
              pos => {this.geo.ok = true; this.geo.lat = pos.coords.latitude; this.geo.lon = pos.coords.longitude; resolve(true);},
              () => resolve(false), {enableHighAccuracy: true, timeout: 5000, maximumAge: 30000}
            );
          }); await p;
        }
      },

      async loadMapPlane() {
        try {
          const patch = await buildTilePatch({lat: this.geo.lat, lon: this.geo.lon}, this.map.zoom);
          const tex = new THREE.CanvasTexture(patch); tex.colorSpace = THREE.SRGBColorSpace; tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping; tex.minFilter = THREE.LinearFilter; tex.magFilter = THREE.LinearFilter;
          const planeSize = 1000, aspect = patch.height / patch.width;
          const ground = new THREE.Mesh(new THREE.PlaneGeometry(planeSize, planeSize * aspect), new THREE.MeshStandardMaterial({map: tex}));
          ground.rotation.x = -Math.PI / 2;
          if (this.map.mesh) {this.three.scene.remove(this.map.mesh); this.map.mesh.geometry.dispose(); this.map.mesh.material.map.dispose(); this.map.mesh.material.dispose();}
          this.three.scene.add(ground); this.map.mesh = ground; this.map.ready = true;
          const centerPx = latLonToGlobalPixels(this.geo.lat, this.geo.lon, this.map.zoom);
          const pxToWorldX = planeSize / patch.width;
          const pxToWorldZ = (planeSize * aspect) / patch.height;
          this.map.transform = {
            centerPx,
            pxToWorldX,
            pxToWorldZ
          };
          // Keep the map plane centered; corrections are applied to the virtual rig instead.
          ground.position.set(0, 0, 0);
        } catch {
          this.map.ready = false;
          this.setLoading(this.loading.progress, 'Map tiles unavailable');
        }
      },

      toggleFrustum() {
        this.frustumVisible = !this.frustumVisible;
        for (const entry of this.cameras) {
          if (entry.rig?.group) entry.rig.group.visible = this.frustumVisible;
        }
      },
    });
  </script>

  <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
</body>

</html>
