<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Recon HUD — Map + MJPEG Frustum</title>

  <script src="https://cdn.tailwindcss.com"></script>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
    }
  }
  </script>

  <style>
    html, body { height: 100%; margin: 0; background: #0b0f14; overflow: hidden; }
    /* Full-viewport WebGL canvas */
    #scene { position: fixed; inset: 0; width: 100vw; height: 100vh; display: block; }
    /* Keep offscreen tile canvas hidden; style doesn't matter but keep consistent */
    #tileCanvas { display: none; }
    .attribution { position: absolute; bottom: 8px; left: 10px; font-size: 11px; color: #aab3c2; opacity: 0.85; z-index: 40; }
  </style>
</head>

<body x-data="hud()" class="overflow-hidden">
  <!-- HUD (pinned on top) -->
  <div class="pointer-events-none absolute top-0 left-0 w-full p-3 flex items-start gap-3 z-50">
    <div class="pointer-events-auto bg-slate-900/80 text-slate-100 rounded-xl p-3 shadow-lg border border-slate-700">
      <div class="text-xs uppercase tracking-wider text-slate-400">Recon Status</div>
      <div class="mt-1 text-sm">
        <div>GPS: <span :class="geo.ok ? 'text-emerald-400' : 'text-amber-400'" x-text="geo.ok ? 'Locked' : 'Fallback'"></span></div>
        <div>Map: <span :class="map.ready ? 'text-emerald-400' : 'text-amber-400'" x-text="map.ready ? 'Ready' : 'Loading'"></span></div>
        <div>Stream: <span :class="stream.ok ? 'text-emerald-400' : 'text-rose-400'" x-text="stream.ok ? ('Receiving @ ' + stream.fps.toFixed(1) + ' fps') : 'Offline'"></span></div>
      </div>
      <div class="mt-2 flex gap-2">
  <!-- Controls hidden per request; keep toggle wired for future -->
  <button @click="toggleFrustum()" class="hidden px-2 py-1 rounded bg-slate-800 hover:bg-slate-700 border border-slate-600 text-xs">Toggle Frustum</button>
</div>
    </div>
  </div>

  <div class="attribution">Map data © <a class="underline" href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors</div>

  <canvas id="scene"></canvas>
  <canvas id="tileCanvas" width="768" height="768"></canvas>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";

    // ---------- Slippy map ----------
    const d2r = d => d * Math.PI / 180;
    function latLonToTileXY(lat, lon, z) {
      const x = Math.floor((lon + 180) / 360 * Math.pow(2, z));
      const y = Math.floor((1 - Math.log(Math.tan(d2r(lat)) + 1/Math.cos(d2r(lat))) / Math.PI) / 2 * Math.pow(2, z));
      return { x, y };
    }
    async function buildTilePatch({ lat, lon }, zoom=16) {
      const { x: cx, y: cy } = latLonToTileXY(lat, lon, zoom);
      const tileSize = 256, grid = 3;
      const canvas = document.getElementById('tileCanvas');
      canvas.width = tileSize * grid; canvas.height = tileSize * grid;
      const ctx = canvas.getContext('2d');
      let ok = 0;
      const loads = [];
      for (let dy=-1; dy<=1; dy++) for (let dx=-1; dx<=1; dx++) {
        const url = `https://tile.openstreetmap.org/${zoom}/${cx+dx}/${cy+dy}.png`;
        loads.push(new Promise(res => {
          const img = new Image(); img.crossOrigin='anonymous';
          img.onload=()=>{ ctx.drawImage(img,(dx+1)*tileSize,(dy+1)*tileSize); ok++; res(); };
          img.onerror=()=>res();
          img.src=url;
        }));
      }
      await Promise.all(loads);
      if (!ok) throw new Error("No tiles loaded");
      return canvas;
    }

    // ---------- MJPEG (canvas-backed, recreate texture on resize) ----------
    class MJPEGTexture {
      constructor(url) {
        this.url = url;
        this.canvas = document.createElement('canvas');
        this.ctx = this.canvas.getContext('2d');

        this.texture = new THREE.CanvasTexture(this.canvas);
        this._setupTex(this.texture);

        this.ok=false; this.fps=0; this._frames=0; this._last=performance.now();
        this._w=0; this._h=0; this._consumers=new Set();
      }
      _setupTex(tex){
        tex.colorSpace = THREE.SRGBColorSpace;
        tex.minFilter = THREE.LinearFilter;
        tex.magFilter = THREE.LinearFilter;
        tex.wrapS = THREE.ClampToEdgeWrapping;
        tex.wrapT = THREE.ClampToEdgeWrapping;
        tex.flipY = true;
        tex.needsUpdate = true;
      }
      attach(material){
        material.map = this.texture;
        material.needsUpdate = true;
        this._consumers.add(material);
      }
      _recreateTextureForSize(w,h){
        const newCanvas = document.createElement('canvas');
        newCanvas.width=w; newCanvas.height=h;
        this.canvas=newCanvas; this.ctx=newCanvas.getContext('2d');
        const old = this.texture;
        this.texture = new THREE.CanvasTexture(this.canvas);
        this._setupTex(this.texture);
        if (old) old.dispose();
        for (const m of this._consumers){ m.map=this.texture; m.needsUpdate=true; }
      }
      async start(onStatus){
        try{
          const resp = await fetch(this.url,{mode:'cors'});
          if(!resp.body) throw new Error('no body');
          const reader = resp.body.getReader();
          let buf=new Uint8Array(0);
          const SOI=[0xFF,0xD8], EOI=[0xFF,0xD9];
          const find=(b,m)=>{for(let i=0;i<b.length-1;i++) if(b[i]===m[0]&&b[i+1]===m[1]) return i; return -1;};
          this.ok=true; onStatus?.(this);
          while(true){
            const {value,done}=await reader.read(); if(done) break;
            if(!value) continue;
            const tmp=new Uint8Array(buf.length+value.length); tmp.set(buf); tmp.set(value,buf.length); buf=tmp;
            while(true){
              const s=find(buf,SOI), e=find(buf,EOI);
              if(s>=0 && e>s){
                const frame=buf.slice(s,e+2); buf=buf.slice(e+2);
                try{
                  const bmp=await createImageBitmap(new Blob([frame],{type:'image/jpeg'}),{imageOrientation:'from-image'});
                  const w=bmp.width|0, h=bmp.height|0;
                  if(!w||!h) continue;
                  if(w!==this._w||h!==this._h){ this._w=w; this._h=h; this._recreateTextureForSize(w,h); }
                  this.ctx.drawImage(bmp,0,0,this._w,this._h);
                  this.texture.needsUpdate=true;
                  this._frames++; const now=performance.now();
                  if(now-this._last>1000){ this.fps=(this._frames*1000)/(now-this._last); this._frames=0; this._last=now; onStatus?.(this); }
                }catch{}
              } else break;
            }
          }
        }catch{ this.ok=false; this.fps=0; onStatus?.(this); }
      }
    }

    // ---------- Three bootstrap ----------
    function bootScene(hooks){
      const canvas=document.getElementById('scene');
      const renderer=new THREE.WebGLRenderer({canvas,antialias:true});
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      const scene=new THREE.Scene();
      scene.background=new THREE.Color(0x0b0f14);
      const camera=new THREE.PerspectiveCamera(60,2,0.1,2000);
      camera.position.set(0,160,260);
      const controls=new OrbitControls(camera,renderer.domElement);
      // Stabilize desktop zoom/pan. DevTools often changes rAF timing and input deltas,
      // which is why things felt smoother when it was open. Normalize against DPR and
      // use damping + screen-space panning for consistent feel.
      const DPR = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
      controls.target.set(0,0,0);
      controls.enableDamping = true;
      controls.dampingFactor = 0.15;
      controls.screenSpacePanning = true;
      controls.zoomToCursor = true;
      controls.zoomSpeed = 0.75 / DPR;     // reduce scroll zoom sensitivity on hi‑DPI
      controls.panSpeed  = 0.75 / DPR;     // reduce mouse pan sensitivity on hi‑DPI
      controls.minDistance = 20;           // sensible dolly clamps
      controls.maxDistance = 1200;
      controls.update();
      scene.add(new THREE.HemisphereLight(0xbcd1ff,0x232b35,0.6));
      const dir=new THREE.DirectionalLight(0xffffff,0.9); dir.position.set(80,120,60); scene.add(dir);
      function resize(){
        const w=window.innerWidth, h=window.innerHeight;
        camera.aspect=w/h; camera.updateProjectionMatrix();
        // Only update drawing buffer size; CSS is locked to 100vw/100vh
        renderer.setSize(w,h,false);
      }
      addEventListener('resize',resize); resize();
      const clock=new THREE.Clock();
      (function tick(){ hooks?.update?.(clock.getDelta()); controls.update(); renderer.render(scene,camera); requestAnimationFrame(tick); })();
      return {scene,camera};
    }

    // ---------- Frustum gizmo that fits the live-feed plane ----------
    function makeRigForScreen(scene, screen, opts = {}){
      const fovDeg = opts.fovDeg ?? 50;
      const far    = opts.far ?? 60;
      const color  = opts.color ?? 0xf6c560;

      const params = screen.geometry.parameters;
      const halfW = (params?.width ?? 1) * 0.5 * screen.scale.x;
      const halfH = (params?.height ?? 1) * 0.5 * screen.scale.y;

      const center = new THREE.Vector3(); screen.getWorldPosition(center);
      const q = new THREE.Quaternion();   screen.getWorldQuaternion(q);

      const n     = new THREE.Vector3(0,0,1).applyQuaternion(q).normalize();
      const right = new THREE.Vector3(1,0,0).applyQuaternion(q).normalize();
      const up    = new THREE.Vector3(0,1,0).applyQuaternion(q).normalize();

      const cTL = center.clone().add(up.clone().multiplyScalar(halfH)).sub(right.clone().multiplyScalar(halfW));
      const cTR = center.clone().add(up.clone().multiplyScalar(halfH)).add(right.clone().multiplyScalar(halfW));
      const cBL = center.clone().sub(up.clone().multiplyScalar(halfH)).sub(right.clone().multiplyScalar(halfW));
      const cBR = center.clone().sub(up.clone().multiplyScalar(halfH)).add(right.clone().multiplyScalar(halfW));

      const dist = halfH / Math.tan(THREE.MathUtils.degToRad(fovDeg * 0.5));
      const origin = center.clone().sub(n.clone().multiplyScalar(dist));

      const farCenter = origin.clone().add(n.clone().multiplyScalar(far));
      const s = far / dist;
      const fTL = farCenter.clone().add(up.clone().multiplyScalar(halfH*s)).sub(right.clone().multiplyScalar(halfW*s));
      const fTR = farCenter.clone().add(up.clone().multiplyScalar(halfH*s)).add(right.clone().multiplyScalar(halfW*s));
      const fBL = farCenter.clone().sub(up.clone().multiplyScalar(halfH*s)).sub(right.clone().multiplyScalar(halfW*s));
      const fBR = farCenter.clone().sub(up.clone().multiplyScalar(halfH*s)).add(right.clone().multiplyScalar(halfW*s));

      const mat = new THREE.LineBasicMaterial({ color, depthTest: true, depthWrite: false });

      const nearRect = new THREE.Line(new THREE.BufferGeometry().setFromPoints([cTL,cTR,cBR,cBL,cTL]), mat);
      const farRect  = new THREE.Line(new THREE.BufferGeometry().setFromPoints([fTL,fTR,fBR,fBL,fTL]), mat);
      const edges    = new THREE.LineSegments(
        new THREE.BufferGeometry().setFromPoints([origin,cTL, origin,cTR, origin,cBL, origin,cBR]),
        mat
      );

      const camGlyph = new THREE.Line(
        new THREE.BufferGeometry().setFromPoints([
          origin.clone().add(right.clone().multiplyScalar(0.6)),
          origin,
          origin.clone().add(right.clone().multiplyScalar(-0.6)),
          origin.clone().add(up.clone().multiplyScalar(0.7))
        ]),
        new THREE.LineBasicMaterial({ color: 0x89b4fa, depthTest: true })
      );

      const normalLine = new THREE.Line(
        new THREE.BufferGeometry().setFromPoints([center, origin]),
        new THREE.LineDashedMaterial({ color, dashSize: 2, gapSize: 1 })
      );
      normalLine.computeLineDistances();

      const group = new THREE.Group();
      group.add(nearRect, farRect, edges, camGlyph, normalLine);
      scene.add(group);
      return { group, origin };
    }

    // ---------- Alpine app ----------
    window.hud=()=>({
      geo:{ok:false,lat:45.813,lon:15.977},
      map:{ready:false,mesh:null,zoom:16},
      stream:{ok:false,fps:0},
      three:null, rig:null, mjpeg:null, frustumVisible:true,

      async init(){
        this.three=bootScene({update:()=>{}});
        this.three.camera.lookAt(0,0,0);

        await this.acquireLocation();
        await this.loadMapPlane();

        // Live feed
        this.mjpeg=new MJPEGTexture('http://127.0.0.1:8080/stream.mjpg');
        this.mjpeg.start(s=>{ this.stream.ok=s.ok; this.stream.fps=s.fps; });

        // Live-feed plane
        const feedW=80, feedH=60;
        const lift = feedH * 0.5;            // raise by half its height
        const screenGeom=new THREE.PlaneGeometry(feedW,feedH);
        const screenMat=new THREE.MeshBasicMaterial({
          side:THREE.DoubleSide, depthTest:false, depthWrite:false, toneMapped:false
        });
        this.mjpeg.attach(screenMat);

        const screen=new THREE.Mesh(screenGeom,screenMat);
        screen.position.set(0, 5 + lift, 0); // lift above ground so it doesn't clip
        screen.rotation.set(-0.15, 0.45, 0.0);
        this.three.scene.add(screen);

        // Frustum gizmo fitted to the raised screen (origin follows automatically)
        this.rig = makeRigForScreen(this.three.scene, screen, { fovDeg:50, far:60, color:0xf6c560 });
        this.rig.group.visible = this.frustumVisible;
      },

      async acquireLocation(){
        const params=new URLSearchParams(location.search);
        if(params.get('lat') && params.get('lon')){
          this.geo.ok=true; this.geo.lat=parseFloat(params.get('lat')); this.geo.lon=parseFloat(params.get('lon')); return;
        }
        const p=new Promise(resolve=>{
          if(!('geolocation' in navigator)) return resolve(false);
          navigator.geolocation.getCurrentPosition(
            pos=>{ this.geo.ok=true; this.geo.lat=pos.coords.latitude; this.geo.lon=pos.coords.longitude; resolve(true); },
            ()=>resolve(false), {enableHighAccuracy:true,timeout:5000,maximumAge:30000}
          );
        });
        await p;
      },

      async loadMapPlane(){
        try{
          const patch=await buildTilePatch({lat:this.geo.lat,lon:this.geo.lon},this.map.zoom);
          const tex=new THREE.CanvasTexture(patch);
          tex.colorSpace=THREE.SRGBColorSpace;
          tex.wrapS=tex.wrapT=THREE.ClampToEdgeWrapping;
          tex.minFilter=THREE.LinearFilter; tex.magFilter=THREE.LinearFilter;

          const planeSize=1000, aspect=patch.height/patch.width;
          const ground=new THREE.Mesh(
            new THREE.PlaneGeometry(planeSize,planeSize*aspect),
            new THREE.MeshStandardMaterial({map:tex})
          );
          ground.rotation.x=-Math.PI/2;

          if(this.map.mesh){
            this.three.scene.remove(this.map.mesh);
            this.map.mesh.geometry.dispose();
            this.map.mesh.material.map.dispose();
            this.map.mesh.material.dispose();
          }
          this.three.scene.add(ground);
          this.map.mesh=ground; this.map.ready=true;
        }catch{ this.map.ready=false; }
      },

      toggleFrustum(){
        this.frustumVisible=!this.frustumVisible;
        if(this.rig?.group) this.rig.group.visible=this.frustumVisible;
      },
    });
  </script>

  <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
</body>
</html>
