<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Frame Delta Visualizer — Webcam</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Load Alpine AFTER deltaLab is defined -->
  <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
  <style>
    html,
    body {
      background: #0b0f14;
    }

    canvas {
      image-rendering: pixelated;
    }
  </style>
</head>

<body class="text-slate-200">
  <div class="max-w-7xl mx-auto p-4" x-data="window.deltaLab()" x-init="init()">
    <header class="mb-4">
      <h1 class="text-2xl font-semibold">Frame Delta Visualizer</h1>
      <p class="text-sm text-slate-400">Per-pixel change between frames. Serve over HTTPS or localhost</p>
    </header>

    <!-- Warnings -->
    <template x-if="!secure">
      <div class="mb-4 rounded-xl border border-amber-500/30 bg-amber-500/10 p-3 text-amber-200">
        This page isn’t in a secure context. Camera access requires HTTPS or
        <code>http://localhost</code>/<code>http://127.0.0.1</code>.
      </div>
    </template>
    <template x-if="!apiAvailable">
      <div class="mb-4 rounded-xl border border-rose-500/30 bg-rose-500/10 p-3 text-rose-200">
        Camera API unavailable. Your browser/settings blocked <code>getUserMedia</code>.
      </div>
    </template>

    <!-- Controls -->
    <div class="grid md:grid-cols-3 gap-4 mb-4">
      <div class="bg-slate-800/60 rounded-xl p-4 space-y-3 ring-1 ring-slate-700">
        <h2 class="font-medium">Camera</h2>
        <div class="flex gap-2">
          <button @click="start()" :disabled="running || !apiAvailable"
            class="px-3 py-1.5 rounded-lg bg-emerald-600/80 hover:bg-emerald-600 disabled:opacity-40">
            Start
          </button>
          <button @click="stop()" :disabled="!running"
            class="px-3 py-1.5 rounded-lg bg-rose-600/80 hover:bg-rose-600 disabled:opacity-40">
            Stop
          </button>
        </div>

        <label class="block text-sm mt-2">Resolution
          <select x-model="preset" class="mt-1 w-full bg-slate-900 border border-slate-700 rounded-lg p-2">
            <option value="640x480">640×480</option>
            <option value="1280x720">1280×720</option>
            <option value="1920x1080">1920×1080</option>
          </select>
        </label>

        <label class="block text-sm mt-2">Device
          <select x-model="deviceId" class="mt-1 w-full bg-slate-900 border border-slate-700 rounded-lg p-2">
            <template x-for="d in devices" :key="d.deviceId">
              <option :value="d.deviceId" x-text="d.label || ('Camera ' + (devices.indexOf(d)+1))"></option>
            </template>
          </select>
        </label>

        <p class="text-xs text-slate-400 mt-1">Status: <span x-text="status"></span></p>
      </div>

      <div class="bg-slate-800/60 rounded-xl p-4 space-y-3 ring-1 ring-slate-700">
        <h2 class="font-medium">Diff Settings</h2>
        <label class="block text-sm">Threshold <span class="text-slate-400">(0–255)</span>
          <input type="range" min="0" max="255" x-model.number="threshold" class="w-full">
          <span class="text-xs text-slate-400" x-text="threshold"></span>
        </label>

        <label class="block text-sm">Overlay Alpha
          <input type="range" min="0" max="100" x-model.number="overlayAlphaPct" class="w-full">
          <span class="text-xs text-slate-400" x-text="(overlayAlphaPct/100).toFixed(2)"></span>
        </label>

        <label class="block text-sm">Blur radius <span class="text-slate-400">(px)</span>
          <input type="range" min="0" max="6" step="1" x-model.number="blur" class="w-full">
          <span class="text-xs text-slate-400" x-text="blur + ' px'"></span>
        </label>
      </div>

      <div class="bg-slate-800/60 rounded-xl p-4 space-y-3 ring-1 ring-slate-700">
        <h2 class="font-medium">Layers</h2>
        <label class="flex items-center gap-2"><input type="checkbox" x-model="show.original"> Original</label>
        <label class="flex items-center gap-2"><input type="checkbox" x-model="show.diff"> Abs Diff (colorized)</label>
        <label class="flex items-center gap-2"><input type="checkbox" x-model="show.delta"> Color Δ
          (per-channel)</label>
        <label class="flex items-center gap-2"><input type="checkbox" x-model="show.overlay"> Overlay on
          Original</label>
      </div>
    </div>

    <!-- Stage -->
    <div class="grid md:grid-cols-2 gap-4">
      <div class="bg-slate-900/60 rounded-xl p-3 ring-1 ring-slate-700">
        <div class="flex items-center justify-between mb-2">
          <h3 class="font-medium">Original</h3>
          <span class="text-xs text-slate-400" x-text="`${width}×${height}`"></span>
        </div>
        <canvas id="cOriginal" class="w-full rounded-lg border border-slate-700" x-show="show.original"></canvas>
        <div x-show="!show.original" class="text-xs text-slate-500 p-2">Hidden</div>
      </div>

      <div class="bg-slate-900/60 rounded-xl p-3 ring-1 ring-slate-700">
        <div class="flex items-center justify-between mb-2">
          <h3 class="font-medium">Abs Diff (colorized)</h3>
          <span class="text-xs text-slate-400">mean(|ΔR|,|ΔG|,|ΔB|)</span>
        </div>
        <canvas id="cDiff" class="w-full rounded-lg border border-slate-700" x-show="show.diff"></canvas>
        <div x-show="!show.diff" class="text-xs text-slate-500 p-2">Hidden</div>
      </div>

      <div class="bg-slate-900/60 rounded-xl p-3 ring-1 ring-slate-700">
        <div class="flex items-center justify-between mb-2">
          <h3 class="font-medium">Color Δ (signed)</h3>
          <span class="text-xs text-slate-400">Δ mapped to 0–255 with 128 as zero</span>
        </div>
        <canvas id="cDelta" class="w-full rounded-lg border border-slate-700" x-show="show.delta"></canvas>
        <div x-show="!show.delta" class="text-xs text-slate-500 p-2">Hidden</div>
      </div>

      <div class="bg-slate-900/60 rounded-xl p-3 ring-1 ring-slate-700">
        <div class="flex items-center justify-between mb-2">
          <h3 class="font-medium">Overlay</h3>
          <span class="text-xs text-slate-400">Original + heatmap (masked by motion)</span>
        </div>
        <canvas id="cOverlay" class="w-full rounded-lg border border-slate-700" x-show="show.overlay"></canvas>
        <div x-show="!show.overlay" class="text-xs text-slate-500 p-2">Hidden</div>
      </div>
    </div>

    <!-- Hidden elements -->
    <video id="video" playsinline class="hidden"></video>
    <canvas id="cPrev" class="hidden"></canvas>
  </div>

  <script>
    // Make it global so Alpine can find it
    window.deltaLab = function () {
      const secure = window.isSecureContext || ['localhost', '127.0.0.1'].includes(location.hostname);

      // Polyfill mediaDevices if needed
      if (!navigator.mediaDevices) navigator.mediaDevices = {};
      if (!navigator.mediaDevices.getUserMedia) {
        const legacy = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
        if (legacy) {
          navigator.mediaDevices.getUserMedia = (constraints) =>
            new Promise((res, rej) => legacy.call(navigator, constraints, res, rej));
        }
      }
      const apiAvailable = !!navigator.mediaDevices.getUserMedia;

      return {
        // env
        secure,
        apiAvailable,

        // state
        running: false,
        status: apiAvailable ? 'idle' : 'camera API unavailable',
        preset: '640x480',
        width: 640,
        height: 480,
        threshold: 20,              // lower by default for subtle motion
        overlayAlphaPct: 50,       // 0..100
        blur: 1,                   // tiny denoise
        show: {original: true, diff: true, delta: true, overlay: true},

        // devices
        devices: [],
        deviceId: '',

        // refs
        _raf: null,
        _stream: null,
        _ctxOriginal: null,
        _ctxDiff: null,
        _ctxDelta: null,
        _ctxOverlay: null,
        _ctxPrev: null,
        _video: null,

        async init() {
          if (!this.apiAvailable) return;
          try {
            // Probe to unlock device labels
            await navigator.mediaDevices.getUserMedia({video: true, audio: false}).then(s => {
              s.getTracks().forEach(t => t.stop());
            }).catch(() => { });
            const list = await navigator.mediaDevices.enumerateDevices();
            this.devices = list.filter(d => d.kind === 'videoinput');
            if (this.devices.length && !this.deviceId) this.deviceId = this.devices[0].deviceId;
          } catch (_) { }
        },

        async start() {
          if (!this.apiAvailable) {this.status = 'camera API unavailable'; return;}
          if (this.running) return;

          const [w, h] = this.preset.split('x').map(Number);
          this.width = w; this.height = h;

          this._video = document.getElementById('video');
          const cOriginal = document.getElementById('cOriginal');
          const cDiff = document.getElementById('cDiff');
          const cDelta = document.getElementById('cDelta');
          const cOverlay = document.getElementById('cOverlay');
          const cPrev = document.getElementById('cPrev');

          for (const c of [cOriginal, cDiff, cDelta, cOverlay, cPrev]) {
            c.width = this.width;
            c.height = this.height;
          }

          this._ctxOriginal = cOriginal.getContext('2d', {willReadFrequently: true});
          this._ctxDiff = cDiff.getContext('2d', {willReadFrequently: true});
          this._ctxDelta = cDelta.getContext('2d', {willReadFrequently: true});
          this._ctxOverlay = cOverlay.getContext('2d', {willReadFrequently: true});
          this._ctxPrev = cPrev.getContext('2d', {willReadFrequently: true});

          try {
            this.status = 'requesting camera...';

            const constraints = {
              video: {
                width: {ideal: this.width},
                height: {ideal: this.height},
                deviceId: this.deviceId ? {exact: this.deviceId} : undefined
              },
              audio: false
            };

            this._stream = await navigator.mediaDevices.getUserMedia(constraints);
            this._video.srcObject = this._stream;
            await this._video.play();

            if (!this.devices.length) {
              const list = await navigator.mediaDevices.enumerateDevices();
              this.devices = list.filter(d => d.kind === 'videoinput');
            }

            this.status = 'streaming';
            this.running = true;
            this._loop();
          } catch (e) {
            const msg = e && e.name ? `${e.name}: ${e.message || ''}` : (e && e.message) || String(e);
            const tips = [];
            if (!this.secure) tips.push('Use HTTPS or http://localhost');
            tips.push('Allow camera permission');
            tips.push('Close other apps using the camera');
            tips.push('Try a different device from the dropdown');
            this.status = `camera error: ${msg} — ${tips.join(' · ')}`;
            this.running = false;
          }
        },

        stop() {
          this.running = false;
          if (this._raf) cancelAnimationFrame(this._raf);
          if (this._stream) this._stream.getTracks().forEach(t => t.stop());
          this.status = 'stopped';
        },

        _loop() {
          if (!this.running) return;

          const w = this.width, h = this.height;

          // 1) draw current frame
          this._ctxOriginal.drawImage(this._video, 0, 0, w, h);

          // 2) read current and previous
          const curr = this._ctxOriginal.getImageData(0, 0, w, h);
          const prev = this._ctxPrev.getImageData(0, 0, w, h);

          // Prepare outputs
          const diffGrayID = this._ctxDiff.createImageData(w, h);     // grayscale magnitude (for reference)
          const diffColorID = this._ctxDiff.createImageData(w, h);     // colorized diff for the panel
          const deltaID = this._ctxDelta.createImageData(w, h);    // signed per-channel
          const overlayID = this._ctxOverlay.createImageData(w, h);  // tinted heatmap with alpha = magnitude

          const c = curr.data, p = prev.data;
          const g = diffGrayID.data, dc = diffColorID.data, ds = deltaID.data, ov = overlayID.data;

          const th = this.threshold;
          const overlayAlpha = this.overlayAlphaPct / 100;

          for (let i = 0; i < c.length; i += 4) {
            const rC = c[i], gC = c[i + 1], bC = c[i + 2];
            const rP = p[i], gP = p[i + 1], bP = p[i + 2];

            const dr = rC - rP;
            const dg = gC - gP;
            const db = bC - bP;

            let mag = (Math.abs(dr) + Math.abs(dg) + Math.abs(db)) / 3;
            if (mag < th) mag = 0;

            // grayscale magnitude
            g[i] = g[i + 1] = g[i + 2] = mag;
            g[i + 3] = 255;

            // colorized diff (orange->yellow ramp)
            const rr = 255;
            const gg = Math.min(255, 80 + mag * 1.1);
            const bb = 0;
            dc[i] = rr; dc[i + 1] = gg; dc[i + 2] = bb; dc[i + 3] = mag > 0 ? 255 : 0;

            // signed color delta (128 = no change)
            ds[i] = Math.max(0, Math.min(255, 128 + dr));
            ds[i + 1] = Math.max(0, Math.min(255, 128 + dg));
            ds[i + 2] = Math.max(0, Math.min(255, 128 + db));
            ds[i + 3] = 255;

            // overlay heatmap with alpha proportional to magnitude and slider
            const a = Math.round((mag / 255) * overlayAlpha * 255);
            ov[i] = rr; ov[i + 1] = gg; ov[i + 2] = bb; ov[i + 3] = a;
          }

          // 3) Paint panels
          // Abs Diff (colorized)
          this._ctxDiff.putImageData(diffColorID, 0, 0);
          if (this.blur > 0) {
            this._ctxDiff.filter = `blur(${this.blur}px)`;
            this._ctxDiff.drawImage(this._ctxDiff.canvas, 0, 0);
            this._ctxDiff.filter = 'none';
          }

          // Color Δ
          this._ctxDelta.putImageData(deltaID, 0, 0);

          // Overlay: original + per-pixel alpha heatmap
          this._ctxOverlay.clearRect(0, 0, w, h);
          this._ctxOverlay.drawImage(this._ctxOriginal.canvas, 0, 0);
          this._ctxOverlay.putImageData(overlayID, 0, 0);

          // 4) store current as previous
          this._ctxPrev.drawImage(this._ctxOriginal.canvas, 0, 0);

          this._raf = requestAnimationFrame(() => this._loop());
        }
      }
    }
  </script>
</body>

</html>
